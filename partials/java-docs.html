<div class="container-fluid">
  <div class="row">
    <div class="col-md-2">
        <div class="well panel panel-default">
            <div class="panel-heading">General</div>
            <div class="panel-body">
                <ul>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('intro')">Intro</button></li>
                </ul>
            </div>
            <div class="panel-heading">Configuration</div>
            <div class="panel-body">
                <ul>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('dependencies')">Dependencies</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('applicationConf')">application.conf</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('plugin')">The Deadbolt plugin</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('deadboltHandler')">DeadboltHandler</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('dynamicResourceHandler')">DynamicResourceHandler</button></li>
                </ul>
            </div>

            <div class="panel-heading">Controllers</div>
            <div class="panel-body">
                <ul>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('controllerSubjectPresent')">SubjectPresent</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('controllerSubjectNotPresent')">SubjectNotPresent</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('controllerRestrict')">Restrict</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('controllerDynamic')">Dynamic</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('controllerPattern')">Pattern</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('controllerUnrestricted')">Unrestricted</button></li>
                </ul>
            </div>

            <div class="panel-heading">Templates</div>
            <div class="panel-body">
                <ul>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('templateUtils')">TemplateUtils</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('templateSubjectPresent')">subjectPresent</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('templateSubjectNotPresent')">subjectNotPresent</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('templateRestrict')">restrict</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('templateDynamic')">dynamic</button></li>
                    <li><button type="button" class="btn btn-link" ng-click="setSection('templatePattern')">pattern</button></li>
                </ul>
            </div>
        </div>
    </div>
    <div class="col-md-10">
      <div ng-if="section == 'intro'">
        <h3>Intro</h3>
          <p>Deadbolt is centered around a single idea - restricting access to a resource to a specific group of users.   This group could be defined by the roles held by subjects, or something completely specific to your application.  Each protected resource can define its own requirements for access, or hand over to a component that will will externalise its authorization concerns.</p>  

            <p><i class="fa fa-exclamation-triangle"></i> I've had several e-mails from developers who have thought that Deadbolt had a "restrict from" approach, and therefore could not understand why the authorisation was failing so spectacularly; to forestall future questions about this, I want to make it completely clear - Deadbolt uses "restrict to". For example, a controller action annotated with @Restrict(@Group("foo")) would only allow users <strong>with</strong> the "foo" role to access the method.</p>

          <p>Two mechanisms are provided to declare these restrictions - one at the template level and another at the controller level.</p>

          <h4>Template-level restrictions</h4>

          <p>For a Play 2 application that uses server-side rendering, Deadbolt provides several template tags that will conceal or reveal DOM elements based on your specifications.</p>

          <p>A couple of basic use cases are

          <ul>
            <li>Only displayed a "Log in" link if there is no user present</li>
            <li>Even if a user is logged in, only display an "Administration" link if the user has administrative privileges</li>
          </ul>
          </p>

          <p>However, it is extremely important to note that using these tags will only give you a cleaner UI, one that is better tailored to the user's privileges. It will not secure your server-side code in any way except - possibly - obscurity. Server-side routes can be invoked from outside of templates by changing the URL in the browser's address bar, using command-line tools such as cURL and many other ways.</p>

          <p>If you have seen the original Dawn Of The Dead (Romero, 1978), you may remember the protagonists concealing the entrance to their living quarters using a panel of painted hardboard. There are no additional defensive layers behind this concealment. When a zombified protagonist breaks through the hardboard, knowing there is something he wants on the other side, all security is gone. Minutes later, there's blood everywhere and the survivors have to flee.</p>

          <p>Template security is like painted hardboard - the features it offers are certainly nice to have, but a further level of defensive depth is required. For this, you need controller action security - otherwise, the zombies will get you.</p>

          <p>If you haven't seen Dawn Of The Dead, sorry for the spoilers.  Now step away from your computer and go watch the movie.</p>

          <h4>Controller-level restrictions</h4>

          <p>The controller layer is most vulnerable part of your application to external attack, because that is the part that's visible to whichever networks it is on. Attack in this sense may be a concious attack on your system, or inadvertant damage caused by unauthorised users who are otherwise authenticated in your system.</p>

          <p>Controller authorisation blocks or allows access to a method. Whereas template restrictions are essentially a boolean evaluation - "if user satisfies these conditions, then...", controller authorisation is quite a bit more powerful. Specifically, while an authorised result is generated from your application code, unauthorised results can be customised as required; you can return any status code you like along with any content you like. If you're feeling particularly nasty, why not send a 302 redirect to a not-suitable-for-work website? If you want to, the option is there.</p>

          <p>A HTTP request has a life cycle. At a high level, it is

          <ul>
            <li>Sent</li>
            <li>Received</li>
            <li>Processed</li>
            <li>Answered</li>
          </ul>
          </p>

          <p>The processed point is where our web applications live. In a sense, the high level life cycle is repeated again here, as the request is sent from the container into the application, received by the app, processed and answered. Deadbolt controller constraints occur at the point where the container (the Play server, in this case) hands the request over to the application; Deadbolt templates work during the processing phase as a response body is rendered.</p>

          <p>A basic, but perfectly valid, example of a controller-level constraint is checking is a subject is present.
<pre>@SubjectPresent
public class MyController extends Controller {
  
  // various action methods, all of which require a subject to be present.
}</pre>          
          </p>

          <p>If you only want individual actions within a controller to be protected, apply the constraint at the method level.
<pre>
public class MyController extends Controller {
  
  public static Result index() {
   // anyone can see this
  }

  @SubjectPresent
  public static Result membersOnly() {
    // You have be be logged in before this method can be successfully invoked
  }
}</pre>
        </p>

        <h4>Rule specificy</h4>
        <p>A rule of "most specific" applies - method constraints are applied before class-level constraints, and if the most specific (i.e. method-level) constraint is satisfied, the class-level constraint will not be applied.</p>
        <p><i class="fa fa-exclamation-triangle"></i>  In the case where a method-level constraint is more specific than a class-level constraint, there is no bubble-up effect.  If the constraint fails for the method, the request fails - the class-level constraint is <strong>NOT</strong> applied as a fall-back.</p>
        <span next-section section="dependencies" label="Dependencies"></span>
      </div>
      <div ng-if="section == 'dependencies'">
        <h3>Dependencies</h3>
        <h4>Repository</h4>
        <p>Deadbolt is currently hosted in the Objectify repository. At some point in the future, it will move to Maven Central. In the meantime, you need to add the following to your Play
        project:
        <pre class="well">resolvers += Resolver.url("Objectify Play Repository", url("http://schaloner.github.io/releases/"))(Resolver.ivyStylePatterns)</pre>
        </p>

        <h4>Which version should I use?</h4>
        <p>To help you choose the correct version to Deadbolt to use, select your preferred language and Play version below.  The necessary SBT dependency will be shown. 

        <div>
            <label for="currentLanguage" id="currentLanguageLabel">Language:</label>
            <select ng-model="currentLanguage" ng-options="availableLanguage as availableLanguage.label for availableLanguage in availableLanguages" id="currentLanguage">
            </select>
        </div>
        <div>
            <label for="playVersion" id="playVersionLabel">Play version:</label>
            <select ng-model="currentPlayVersion" ng-options="availableVersion as availableVersion.label for availableVersion in availableVersions" id="playVersion">
            </select>
        </div>
        <div ng-repeat="javaVersion in javaVersions | filter:{playVersion:currentPlayVersion.value}:true" ng-if="currentLanguage.value == 'java' || currentLanguage.value == 'all'">
          <label>SBT dependency:</label>
          <pre class="code">"{{javaVersion.groupId}}" %% "{{javaVersion.artifactId}}" % "{{javaVersion.version}}"</pre>
        </div>
        <div ng-repeat="scalaVersion in scalaVersions | filter:{playVersion:currentPlayVersion.value}:true" ng-if="currentLanguage.value == 'scala' || currentLanguage.value == 'all'">
          <label>SBT dependency:</label>
          <pre class="code">"{{scalaVersion.groupId}}" %% "{{scalaVersion.artifactId}}" % "{{scalaVersion.version}}"</pre>
        </div>

        <span next-section section="applicationConf" label="application.conf"></span>
      </div>
      <div ng-if="section == 'applicationConf'">
        <h3>application.conf</h3>
        <p>The high-level configuration of Deadbolt is specified in <code>application.conf</code>.</p>

        <h4>deadbolt.java.handler</h4>
        <p>This tells Deadbolt which handler you wish to use as a default when one isn't explicitly specified in the Deadbolt constraint. This will be explained in more detail when we look at the individual constraints.</p>

        <p>For a DeadboltHandler implementation whose fully-qualified name is <code>com.example.myapp.security.MyDeadboltHandler</code>, your <code>application.conf</code> would have the entry

<pre>deadbolt.java.handler=com.example.myapp.security.MyDeadboltHandler</pre></p>

<p>Personally, I prefer the HOCON (Human-Optimized Config Object Notation) syntax supported by Play, so I would recommend the following:

<pre>deadbolt {
    java {
        handler=com.example.myapp.security.MyDeadboltHandler
    }
}</pre></p>

        <h4>deadbolt.java.cache-user</h4>
        <p>By default, Deadbolt does not cache the subject returned from <code>DeadboltHandler#getSubject</code>.  This means that if your implementation of this method retrieves the user from the database, that database call will be made every time the subject is required.  For templates, this can get quite expensive.</p>

        <p>If you want the subject to be cached, resulting in a maximum of one call to <code>DeadboltHandler#getSubject</code> per request, you can set the <code>deadbolt.java.cache-user</code> flag.
<pre>deadbolt {
    java {
        cache-user=true
    }
}</pre></p>

        <h4>deadbolt.before-auth-check-timeout</h4>
        <p>Internal calls to <code>DeadboltHandler#beforeAuthCheck</code> receive a Promise, and use a default timeout of 2000 milliseconds when redeeming it.  If you want to change the timeout period, set <code>deadbolt.before-auth-check-timeout</code>.</p>

        <p>Two important things to note:
          <ul>
            <li>The value is in milleseconds, not seconds.</li>
            <li>The key does NOT contain <code>.java</code></li>
          </ul>
        </p>

<pre>deadbolt {
    # Use a 4000 millisecond timeout when getting the result from the beforeAuthCheck promise
    before-auth-check-timeout=4000
}</pre>

        <h4>deadbolt.java.handlers</h4>
        <p>No, that's not a typo and this is not accidentally repeated content.  All Deadbolt controller constraints have a <code>handlerKey</code> attribute.  The value of that attribute, if it matches the key in the <code>deadbolt.java.handlers</code> object, will be used as the <code>DeadboltHandler</code> for the request.</p>

<pre>deadbolt {
    java {
        handlers {
            foo=com.example.security.FooDeadboltHandler,
            bar=com.example.security.BarDeadboltHandler
        }
    }
}</pre>

        <p>
          If you don't want to have both <code>deadbolt.java.handler</code> and <code>deadbolt.java.handlers</code>, which can be a little confusing, you can do it all with <code>deadbolt.java.handlers</code>.  Internally, <code>deadbolt.java.handler</code> is treated as <code>deadbolt.java.handlers.defaultHandler</code>.  Therefore, you can take a configuration that looks like this

<pre>
deadbolt {
    java {
        handler=com.example.security.MyDeadboltHandler
        handlers {
            foo=com.example.security.FooDeadboltHandler,
            bar=com.example.security.BarDeadboltHandler
        }
    }
}</pre>

you could rewrite it as 
<pre>
deadbolt {
    java {
        handlers {
            defaultHandler=com.example.security.MyDeadboltHandler,
            foo=com.example.security.FooDeadboltHandler,
            bar=com.example.security.BarDeadboltHandler
        }
    }
}</pre>
        </p>

        <p>If, for whatever reason, you have both <code>deadbolt.java.handler</code> and <code>deadbolt.java.handlers.defaultHandler</code> defined in your configuration, the definition of <code>deadbolt.java.handler</code> will take precedence.</p>

        <h4>Putting it all together</h4>
        <p>A complete example configuration would therefore look something like this.

<pre>deadbolt {
    before-auth-check-timeout=4000,
    java {
        cache-user=true,
        handlers {
            defaultHandler=com.example.security.MyDeadboltHandler,
            foo=com.example.security.FooDeadboltHandler,
            bar=com.example.security.BarDeadboltHandler
        }
    }
}</pre></p>
        

        <span next-section section="plugin" label="The Deadbolt plugin"></span>
      </div>
      <div ng-if="section == 'plugin'">
        <h3>Plugin</h3>
        <div>
            <p>The initial version of Deadbolt held the default DeadboltHandler implementation, as specific in application.conf, as a static variable. This led immediately to problems with the hot reload carried out by Play when it detects code changes at runtime. To address this issue, the default handler is now created by and held in a plugin, whose lifecycle is managed by the framework.</p>

            <p>To activate the plugin, you need to update your <code>conf/play.plugins</code> file. If this file doesn't already exist (it's not created automatically when you create a new Play app), then add it yourself. The necessary line is

<pre class="code">10000:be.objectify.deadbolt.java.DeadboltPlugin</pre></p>

            <p>The 10000 defines the loading priority of the plugin -lower numbers are loaded first. If you have no other plugins, this is irrelevant. If you do have other plugins, you'll need to work out the best way to order them. Deadbolt should, in theory and so far in practice, play nicely with other modules so its loading priority (again, in theory) should not matter. File this under "Things I should be aware of".</p>

            <p>When the plugin starts, it will attempt to read the class name specified by <code>deadbolt.java.handler</code> in <code>application.conf</code>. If found, an instance of the class will then be instantiated. If the instantiation fails, an exception will be thrown so you receive a fail-fast response on start-up.</p>

            <p><i class="fa fa-exclamation-triangle"></i> It is a valid scenario to have no default handler specified. If <code>deadbolt.java.handler</code> doesn't appear in your configuration, a warning will be logged to alert you of this.</p>
        </div>
        <span next-section section="deadboltHandler" label="DeadboltHandler"></span>
      </div>
      <div ng-if="section == 'deadboltHandler'">
        <h3>DeadboltHandler</h3>
        <p>In order for Deadbolt to do its thing, it'll need some information from your application.  To provide this, you need to implement the <code>be.objectify.deadbolt.java.DeadboltHandler</code> interface. The four methods defined by this interface are crucial to Deadbolt - they are used to access the current user (or subject, to use the correct security terminology), determine what to do on an authorization failure, etc.</p>

        <p>Each <code>DeadboltHandler</code> instance declared in the configuration (see <button type="button" class="btn btn-link" ng-click="setSection('applicationConf')">application.conf</button>) is cached, and shared between requests and so should be stateless and lightweight.</p>

        <h4>Subject getSubject(Http.Context context)</h4>
        <p>Gets the current <code>be.objectify.deadbolt.core.models.Subject</code>, e.g. the current user.</p>

        <h4>F.Promise<Result> beforeAuthCheck(Http.Context context)</h4>
        <p>Invoked immediately before controller or view restrictions are checked. This forms the integration point with any authentication actions that may need to occur.</p>

        <h4>F.Promise<Result> onAuthFailure(Http.Context context, String content)</h4>
        <p>Invoked when an authorization failure occurs.  The <code>content</code> parameter is passed in from the <code>content</code> attribute of the controller constraints.</p>

        <h4>DynamicResourceHandler getDynamicResourceHandler(Http.Context context)</h4>
        <p>Gets an instance of <code>be.objectify.deadbolt.java.DynamicResourceHandler</code>.  More information is present in the <button type="button" class="btn btn-link" ng-click="setSection('dynamicResourceHandler')">DynamicResourceHandler</button> section.</p>

        <span next-section section="dynamicResourceHandler" label="DynamicResourceHandler"></span>
      </div>
      <div ng-if="section == 'dynamicResourceHandler'">
        <h3>DynamicResourceHandler</h3>
        <p>To deal with dynamic constraints, i.e. <code>@Dynamic</code> and <code>@Pattern</code>, you're going to need to do some work because the constraints are completely arbitrary.</p>

        <h4>boolean isAllowed(String name, String meta, DeadboltHandler deadboltHandler, Http.Context ctx)</h4>
        <p>Check the access of the named resource, when a <code>@Dynamic</code> constraint is used.  Take a look at the page for <button type="button" class="btn btn-link" ng-click="setSection('controllerDynamic')">Dynamic</button> to see more information.</p>
        <p>It's often useful to delegate the call to this method to something specific to the resource name.  Otherwise, this method can end up looking like if-then-else hell.</p>

        <h4>boolean checkPermission(String permissionValue, DeadboltHandler deadboltHandler, Http.Context ctx)</h4>
        <p>When a <code>@Pattern</code> constraint of type <code>PatternType.CUSTOM</code> is used, this method is used to check authorization.  Take a look at the page for <button type="button" class="btn btn-link" ng-click="setSection('controllerPattern')">Pattern</button> to see more information.</p>

        <span next-section section="controllerSubjectPresent" label="SubjectPresent"></span>
      </div>
      <div ng-if="section == 'controllerSubjectPresent'">
        <h3>@SubjectPresent</h3>

        <p>A subject must be provided by the <code>DeadboltHandler</code> to have access to the resource, but no role checks are performed.</p>

        <h4>Attributes</h4>
        <table class="table table-striped table-bordered">
          <thead>
              <tr>
                <th>Name</th>
                <th>Default value</th>
                <th>Description</th>
              </tr>
          </thead>
          <tbody>
            <tr>
              <td>content</td>
              <td><code>""</code></td>
              <td>Indicates the expected response type. Useful when working with non-HTML responses. This is free text, which you can use in <code>DeadboltHandler#onAuthFailure</code> to decide on how to handle the response.</td>
              <td></td>
            </tr>
            <tr>
              <td>handler</td>
              <td><code>DeadboltHandler.class</code></td>
              <td>
                Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one.
                <div><i class="fa fa-exclamation-triangle"></i> Deprecated - use handlerKey instead.</div>
              </td>
            </tr>
            <tr>
              <td>handlerKey</td>
              <td><code>""</code></td>
              <td>Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one, identified by a key.  The key/value pair is specified in application.conf.</td>
              <td></td>
            </tr>
            <tr>
              <td>deferred</td>
              <td><code>false</code></td>
              <td>If true, the annotation will only be run if there is a <code>@DeferredDeadbolt</code> annotation at the class level.</td>
              <td></td>
            </tr>
            <tr>
              <td>forceBeforeAuthCheck</td>
              <td><code>false</code></td>
              <td>Indicates if <code>DeadboltHandler#beforeAuthCheck</code> should be invoked before this constraint is applied. Defaults to false for historic and generally good reasons, namely that a handler that complains based on user presence can shortcut this constraint.</td>
              <td></td>
            </tr>
          </tbody>
        </table>

        <span next-section section="controllerSubjectNotPresent" label="SubjectNotPresent"></span>
      </div>
      <div ng-if="section == 'controllerSubjectNotPresent'">
        <h3>@SubjectNotPresent</h3>

        <p>The subject provided by the <code>DeadboltHandler</code> must be null to have access to the resource.</p>

        <h4>Attributes</h4>
        <table class="table table-striped table-bordered">
          <thead>
              <tr>
                <th>Name</th>
                <th>Default value</th>
                <th>Description</th>
              </tr>
          </thead>
          <tbody>
            <tr>
              <td>content</td>
              <td><code>""</code></td>
              <td>Indicates the expected response type. Useful when working with non-HTML responses. This is free text, which you can use in <code>DeadboltHandler#onAuthFailure</code> to decide on how to handle the response.</td>
              <td></td>
            </tr>
            <tr>
              <td>handler</td>
              <td><code>DeadboltHandler.class</code></td>
              <td>
                Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one.
                <div><i class="fa fa-exclamation-triangle"></i> Deprecated - use handlerKey instead.</div>
              </td>
            </tr>
            <tr>
              <td>handlerKey</td>
              <td><code>""</code></td>
              <td>Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one, identified by a key.  The key/value pair is specified in application.conf.</td>
              <td></td>
            </tr>
            <tr>
              <td>deferred</td>
              <td><code>false</code></td>
              <td>If true, the annotation will only be run if there is a <code>@DeferredDeadbolt</code> annotation at the class level.</td>
              <td></td>
            </tr>
            <tr>
              <td>forceBeforeAuthCheck</td>
              <td><code>false</code></td>
              <td>Indicates if <code>DeadboltHandler#beforeAuthCheck</code> should be invoked before this constraint is applied. Defaults to false for historic and generally good reasons, namely that a handler that complains based on user presence can shortcut this constraint.</td>
              <td></td>
            </tr>
          </tbody>
        </table>

        <span next-section section="controllerRestrict" label="Restrict"></span>
      </div>
      <div ng-if="section == 'controllerRestrict'">
        <h3>@Restrict</h3>
        <p>Restricts access to a controller, allowing only subjects with the necessary role(s) to make a successful call.  Roles are defined in one or more <code>@Group</code> annotations.</p>
        <p>Within an <code>Group</code>, roles are ANDed, and between Group the role groups are ORed.</p>
        <p>For example <code>@Restrict({@Group("foo")</code>, <code>@Group("hurdy", "gurdy")})</code> means the subject must have either the foo role OR both the hurdy AND gurdy roles.</p>
        <p>Role names that start with <code>!</code> are negated, so <code>@Restrict({@Group("foo", "bar"), @Group("hurdy", "!gurdy")})</code> requires the subject to have either the foo role AND the bar roles, or the hurdy AND NOT the gurdy roles.</p>

        <h4>Attributes</h4>
        <table class="table table-striped table-bordered">
          <thead>
              <tr>
                <th>Name</th>
                <th>Default value</th>
                <th>Description</th>
              </tr>
          </thead>
          <tbody>
            <tr>
              <td>value</td>
              <td></td>
              <td>The combination of roles required to allow access.</td>
              <td></td>
            </tr>
            <tr>
              <td>content</td>
              <td><code>""</code></td>
              <td>Indicates the expected response type. Useful when working with non-HTML responses. This is free text, which you can use in <code>DeadboltHandler#onAuthFailure</code> to decide on how to handle the response.</td>
              <td></td>
            </tr>
            <tr>
              <td>handler</td>
              <td><code>DeadboltHandler.class</code></td>
              <td>
                Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one.
                <div><i class="fa fa-exclamation-triangle"></i> Deprecated - use handlerKey instead.</div>
              </td>
            </tr>
            <tr>
              <td>handlerKey</td>
              <td><code>""</code></td>
              <td>Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one, identified by a key.  The key/value pair is specified in application.conf.</td>
              <td></td>
            </tr>
            <tr>
              <td>deferred</td>
              <td><code>false</code></td>
              <td>If true, the annotation will only be run if there is a <code>@DeferredDeadbolt</code> annotation at the class level.</td>
              <td></td>
            </tr>
          </tbody>
        </table>

        <span next-section section="controllerDynamic" label="Dynamic"></span>
      </div>
      <div ng-if="section == 'controllerDynamic'">
        <h3>@Dynamic</h3>

        <p>This is the most flexible constraint.  The implementation of the block/allow behaviour is provided through a <code>DynamicResourceHandler</code>, so you can write anything you want in there.</p>

        <h4>Attributes</h4>
        <table class="table table-striped table-bordered">
          <thead>
              <tr>
                <th>Name</th>
                <th>Default value</th>
                <th>Description</th>
              </tr>
          </thead>
          <tbody>
            <tr>
              <td>value</td>
              <td></td>
              <td>The name of the resource.  This will be passed into the <code>DynamicResourceHandler</code> returned by the current <code>DeadboltHandler</code>.</td>
              <td></td>
            </tr>
            <tr>
              <td>meta</td>
              <td><code>""</code></td>
              <td>Additional information when deciding on access to the resource. It's a free formatted string, so you can pass simple data or more complex string such as foo=bar,hurdy=gurdy which can be parsed into a map.</td>
              <td></td>
            </tr>
            <tr>
              <td>content</td>
              <td><code>""</code></td>
              <td>Indicates the expected response type. Useful when working with non-HTML responses. This is free text, which you can use in <code>DeadboltHandler#onAuthFailure</code> to decide on how to handle the response.</td>
              <td></td>
            </tr>
            <tr>
              <td>handler</td>
              <td><code>DeadboltHandler.class</code></td>
              <td>
                Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one.
                <div><i class="fa fa-exclamation-triangle"></i> Deprecated - use handlerKey instead.</div>
              </td>
            </tr>
            <tr>
              <td>handlerKey</td>
              <td><code>""</code></td>
              <td>Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one, identified by a key.  The key/value pair is specified in application.conf.</td>
              <td></td>
            </tr>
            <tr>
              <td>deferred</td>
              <td><code>false</code></td>
              <td>If true, the annotation will only be run if there is a <code>@DeferredDeadbolt</code> annotation at the class level.</td>
              <td></td>
            </tr>
            <tr>
              <td>forceBeforeAuthCheck</td>
              <td><code>false</code></td>
              <td>Indicates if <code>DeadboltHandler#beforeAuthCheck</code> should be invoked before this constraint is applied. Defaults to false for historic and generally good reasons, namely that a handler that complains based on user presence can shortcut this constraint.</td>
              <td></td>
            </tr>
          </tbody>
        </table>

        <span next-section section="controllerPattern" label="Pattern"></span>
      </div>
      <div ng-if="section == 'controllerPattern'">
        <h3>@Pattern</h3>

        <p>The Pattern constraint is used to test the permissions (not roles!) of the subject.  Three types of matching are supported, as specified by <code>be.objectify.deadbolt.core.PatternType</code>.</p>
        <ul>
          <li><code>PatternType.EQUALITY</code> - Checks the pattern against the permissions of the user.  Exact, case-sensitive matches only!</li>
          <li><code>PatternType.REGEX</code> - A standard regular expression that will be evaluated against the permissions of the subject.</li>
          <li><code>PatternType.CUSTOM</code> - Perform some custom matching on the pattern, using <code>DynamicResourceHandler#checkPermission</code>.</li>
        </ul>

        <h4>Attributes</h4>
        <table class="table table-striped table-bordered">
          <thead>
              <tr>
                <th>Name</th>
                <th>Default value</th>
                <th>Description</th>
              </tr>
          </thead>
          <tbody>
            <tr>
              <td>value</td>
              <td></td>
              <td>The pattern.</td>
              <td></td>
            </tr>
            <tr>
              <td>patternType</td>
              <td><code>PatternType.EQUALITY</code></td>
              <td>The type of pattern matching required.</td>
              <td></td>
            </tr>
            <tr>
              <td>content</td>
              <td><code>""</code></td>
              <td>Indicates the expected response type. Useful when working with non-HTML responses. This is free text, which you can use in <code>DeadboltHandler#onAuthFailure</code> to decide on how to handle the response.</td>
              <td></td>
            </tr>
            <tr>
              <td>handler</td>
              <td><code>DeadboltHandler.class</code></td>
              <td>
                Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one.
                <div><i class="fa fa-exclamation-triangle"></i> Deprecated - use handlerKey instead.</div>
              </td>
            </tr>
            <tr>
              <td>handlerKey</td>
              <td><code>""</code></td>
              <td>Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one, identified by a key.  The key/value pair is specified in application.conf.</td>
              <td></td>
            </tr>
            <tr>
              <td>deferred</td>
              <td><code>false</code></td>
              <td>If true, the annotation will only be run if there is a <code>@DeferredDeadbolt</code> annotation at the class level.</td>
              <td></td>
            </tr>
            <tr>
              <td>forceBeforeAuthCheck</td>
              <td><code>false</code></td>
              <td>Indicates if <code>DeadboltHandler#beforeAuthCheck</code> should be invoked before this constraint is applied. Defaults to false for historic and generally good reasons, namely that a handler that complains based on user presence can shortcut this constraint.</td>
              <td></td>
            </tr>
          </tbody>
        </table>

        <span next-section section="controllerUnrestricted" label="Unrestricted"></span>
      </div>
      <div ng-if="section == 'controllerUnrestricted'">
        <h3>@Unrestricted</h3>

        <p>Indicates there are no restrictions on the resource.</p>

        <h4>Attributes</h4>
        <table class="table table-striped table-bordered">
          <thead>
              <tr>
                <th>Name</th>
                <th>Default value</th>
                <th>Description</th>
              </tr>
          </thead>
          <tbody>
            <tr>
              <td>content</td>
              <td><code>""</code></td>
              <td>Indicates the expected response type. Useful when working with non-HTML responses. This is free text, which you can use in <code>DeadboltHandler#onAuthFailure</code> to decide on how to handle the response.</td>
              <td></td>
            </tr>
            <tr>
              <td>handler</td>
              <td><code>DeadboltHandler.class</code></td>
              <td>
                Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one.
                <div><i class="fa fa-exclamation-triangle"></i> Deprecated - use handlerKey instead.</div>
              </td>
            </tr>
            <tr>
              <td>handlerKey</td>
              <td><code>""</code></td>
              <td>Use a specific <code>DeadboltHandler</code> implementation for this restriction in place of the global one, identified by a key.  The key/value pair is specified in application.conf.</td>
              <td></td>
            </tr>
            <tr>
              <td>deferred</td>
              <td><code>false</code></td>
              <td>If true, the annotation will only be run if there is a <code>@DeferredDeadbolt</code> annotation at the class level.</td>
              <td></td>
            </tr>
          </tbody>
        </table>

        <span next-section section="templateUtils" label="TemplateUtils"></span>
      </div>
      <div ng-if="section == 'templateUtils'">
          <h3>TemplateUtils</h3>
          <p>To assist in creating the structures needed to define constraints in Play templates, you can import and use <code>be.objectify.deadbolt.core.utils.TemplateUtils</code>.  This class
          provides shorthand methods that reduce clutter in your code.</p>
          <p>The following sections on template constraints will reference <code>as</code> and <code>la</code> - these methods are explained below.</p>
          <table class="table table-striped table-bordered">
              <thead>
              <tr>
                  <th>Signature</th>
                  <th>Description</th>
              </tr>
              </thead>
              <tbody>
              <tr>
                  <td>String[] as(String... args)</td>
                  <td>Converts the argument into an array of Strings.</td>
              </tr>
              <tr>
                  <td>List&lt;String[]&gt; la(String[]... args)</td>
                  <td>Converts the argument array into a list of String arrays.</td>
              </tr>
              </tbody>
          </table>
        <span next-section section="templateSubjectPresent" label="subjectPresent"></span>
      </div>
      <div ng-if="section == 'templateSubjectPresent'">
        <h3>subjectPresent</h3>
        <p>Any template content wrapped by <code>subjectPresent</code> will only appear if a subject can be resolved by the current <code>DeadboltHandler</code>.  The <code>DeadboltHandler</code> can be specific or generic, i.e. you can use <code>@subjectPresent()</code> or <code>@subjectPresent(someSpecificDeadboltHandler)</code>.</p>
        <p>A variation, <code>subjectPresentOr</code>, allows you to specify content to be displayed if the authorisation fails.</p>
        <p><code>subjectPresent</code> is the template equivalent to the <button type="button" class="btn btn-link" ng-click="setSection('controllerSubjectPresent')">SubjectPresent</button> controller constraint.</p>

        <h4>Imports</h4>
        <p>To use <code>subjectPresent</code> or <code>subjectPresentOr</code>, add the following import to your template.
          <pre>@import be.objectify.deadbolt.java.views.html._</pre>
        </p>

        <h4>Examples</h4>
        <p>All examples are valid for both <code>subjectPresent</code> and <code>subjectPresentOr</code>.</p>
        <p><strong>Basic usage</strong>
<pre>@subjectPresent() {
  This content will be visible if a subject is present.
}</pre>
        </p>

        <p><strong>Fallback content</strong>
<pre>@subjectPresentOr() {
  This content will be visible if a subject is present.
}{
  This content will be present if no subject is present.
}</pre>
        </p>

        <p><strong>Define a <code>DeadboltHandler</code> in the template.</strong>  This is possible, but I recommend against it as it can reduce code re-use.  See the next example for a better approach.
<pre>@subjectPresent(new com.example.security.FooDeadboltHandler()) {
  This content will be visible if a subject is present.
}</pre>
        </p>

        <p><strong>Pass a <code>DeadboltHandler</code> into the template.</strong>  This provides a more flexible approach to hard-coding the <code>DeadboltHandler</code> in the template.
<pre>@(mySpecificDeadboltHandler: be.objectify.deadbolt.java.DeadboltHandler)

@subjectPresent(mySpecificDeadboltHandler) {
  This content will be visible if a subject is present.
}</pre>
        </p>
        <span next-section section="templateSubjectNotPresent" label="subjectNotPresent"></span>
      </div>
      <div ng-if="section == 'templateSubjectNotPresent'">
        <h3>subjectNotPresent</h3>
        <p>Any template content wrapped by <code>subjectNotPresent</code> will only appear if a subject <strong>cannot</strong> be resolved by the current <code>DeadboltHandler</code>.  The <code>DeadboltHandler</code> can be specific or generic, i.e. you can use <code>@subjectNotPresent()</code> or <code>@subjectNotPresent(someSpecificDeadboltHandler)</code>.</p>
        <p>A variation, <code>subjectNotPresentOr</code>, allows you to specify content to be displayed if the authorisation fails.</p>
        <p><code>subjectNotPresent</code> is the template equivalent to the <button type="button" class="btn btn-link" ng-click="setSection('controllerSubjectNotPresent')">SubjectNotPresent</button> controller constraint.</p>

        <h4>Imports</h4>
        <p>To use <code>subjectNotPresent</code> or <code>subjectNotPresentOr</code>, add the following import to your template.
          <pre>@import be.objectify.deadbolt.java.views.html._</pre>
        </p>

        <h4>Examples</h4>
        <p>All examples are valid for both <code>subjectNotPresent</code> and <code>subjectNotPresentOr</code>.</p>
        <p><strong>Basic usage</strong>
<pre>@subjectNotPresent() {
  This content will be visible if a subject is not present.
}</pre>
        </p>

        <p><strong>Fallback content</strong>
<pre>@subjectNotPresentOr() {
  This content will be visible if a subject is not present.
}{
  This content will be present if a subject is present.
}</pre>
        </p>

        <p><strong>Define a <code>DeadboltHandler</code> in the template.</strong>  This is possible, but I recommend against it as it can reduce code re-use.  See the next example for a better approach.
<pre>@subjectNotPresent(new com.example.security.FooDeadboltHandler()) {
  This content will be visible if a subject is not present.
}</pre>
        </p>

        <p><strong>Pass a <code>DeadboltHandler</code> into the template.</strong>  This provides a more flexible approach to hard-coding the <code>DeadboltHandler</code> in the template.
<pre>@(mySpecificDeadboltHandler: be.objectify.deadbolt.java.DeadboltHandler)

@subjectNotPresent(mySpecificDeadboltHandler) {
  This content will be visible if a subject is not present.
}</pre>
        </p>
        <span next-section section="templateRestrict" label="restrict"></span>
      </div>
      <div ng-if="section == 'templateRestrict'">
        <h3>restrict</h3>
        <p><code>restrict</code> uses an ANDed set of roles within an array to determine if the content it wraps should be included in the response.  For example, a user with the roles "foo" and "bar" could see <code>restrict</code>-protected content that specified any of the following roles:
          <ul>
            <li>foo</li>
            <li>bar</li>
            <li>foo AND bar</li>
          </ul>
        </p>
        <p>However, a <code>restrict</code> that required "foo", "bar" and "hurdy" would not allow the protected content into the response.</p>
        <p><i class="fa fa-exclamation-triangle"/> If multiple arrays of roles are defined, the relationship between the arrays is OR.  This will be covered in more detail in the examples.</p>

        <p>A variation, <code>restrictOr</code>, allows you to specify content to be displayed if the authorisation fails.</p>

        <h4>Imports</h4>
        <p>To use <code>restrict</code> you'll need to import a couple of things.
          <pre>@import be.objectify.deadbolt.java.views.html._
@import be.objectify.deadbolt.core.utils.TemplateUtils._</pre>
        </p>

        <h4>Parameters</h4>
        <table class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Name</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>roles</td>
              <td>List[Array[String]]</td>
              <td>The roles the subject must hold for successful authorization.</td>
            </tr>
            <tr>
              <td>handler</td>
              <td>be.objectify.deadbolt.java.DeadboltHandler</td>
              <td>A <code>DeadboltHandler</code> to use when evaluating the authorization.  If null, the default <code>DeadboltHandler</code> will be used.</td>
            </tr>
          </tbody>
        </table>

        <h4>Examples</h4>
        <p><strong>Simple usage</strong>
          <pre>@restrict(la(as("foo"))) {
  This content will be visible if the user has the "foo" role.
}</pre>
        </p>

          <p><strong>Fallback content</strong>
          <pre>@restrictOr(la(as("foo"))) {
  This content will be visible if the user has the "foo" role.
}{
  This content will be visible if the user don't have the "foo" role.
}</pre>
          </p>

          <p><strong>ORing roles</strong>
          <pre>@restrictOr(la(as("foo", "bar"), as("hurdy"))) {
  This content will be visible if the user has the "foo" AND "bar" roles, or the "hurdy" role.
}{
  This content will be visible if the authorisation fails.
}</pre>
          </p>

          <p><strong>Define a <code>DeadboltHandler</code> in the template.</strong>  This is possible, but I recommend against it as it can reduce code re-use.  See the next example for a better approach.
          <pre>@(mySpecificDeadboltHandler: be.objectify.deadbolt.java.DeadboltHandler)

@restrictOr(la(as("foo", "bar"), as("hurdy")), mySpecificDeadboltHandler) {
  This content will be visible if the user has the "foo" AND "bar" roles, or the "hurdy" role.
}{
  This content will be visible if the authorisation fails.
}</pre>
          </p>

          <p><strong>Pass a <code>DeadboltHandler</code> into the template.</strong>  This provides a more flexible approach to hard-coding the <code>DeadboltHandler</code> in the template.
          <pre>@(mySpecificDeadboltHandler: be.objectify.deadbolt.java.DeadboltHandler)

@restrictOr(la(as("foo", "bar"), as("hurdy")), mySpecificDeadboltHandler) {
  This content will be visible if the user has the "foo" AND "bar" roles, or the "hurdy" role.
}{
  This content will be visible if the authorisation fails.
}</pre>
          </p>
          <span next-section section="templateDynamic" label="dynamic"></span>
      </div>
      <div ng-if="section == 'templateDynamic'">
        <h3>dynamic</h3>
          <p><code>dynamic</code> allows you to use custom constraints to determine if the content it wraps should be included in the response.</p>

          <p>A variation, <code>dynamicOr</code>, allows you to specify content to be displayed if the authorisation fails.</p>

          <h4>Imports</h4>
          <p>To use <code>restrict</code> you'll need to import a couple of things.
          <pre>@import be.objectify.deadbolt.java.views.html._
@import be.objectify.deadbolt.core.utils.TemplateUtils._</pre>
          </p>

          <h4>Parameters</h4>
          <table class="table table-striped table-bordered">
              <thead>
              <tr>
                  <th>Name</th>
                  <th>Type</th>
                  <th>Description</th>
              </tr>
              </thead>
              <tbody>
              <tr>
                  <td>name</td>
                  <td>String</td>
                  <td>The name of the custom authorization constraint.</td>
              </tr>
              <tr>
                  <td>meta</td>
                  <td>String</td>
                  <td>Additional information that will be passed into <code>DynamicResourceHandler#isAllowed</code>.</td>
              </tr>
              <tr>
                  <td>handler</td>
                  <td>be.objectify.deadbolt.java.DeadboltHandler</td>
                  <td>A <code>DeadboltHandler</code> to use when evaluating the authorization.  If null, the default <code>DeadboltHandler</code> will be used.</td>
              </tr>
              </tbody>
          </table>

          <h4>Examples</h4>
          <p><strong>Simple usage</strong>
          <pre>@dynamic(name="foo") {
  This content will be visible if allowed by the custom constaint "foo", as executed by the <code>DynamicResourceHandler</code> obtained from the current <code>DeadboltHandler</code>.
}</pre>
          </p>

          <p><strong>Fallback content</strong>
          <pre>@dynamicOr(name="foo") {
  This content will be visible if allowed by the custom constaint "foo", as executed by the <code>DynamicResourceHandler</code> obtained from the current <code>DeadboltHandler</code>.
}{
  This content will be visible if the authorization fails.
}</pre>
          </p>

          <p><strong>Provide meta information</strong>
          <pre>@dynamicOr(name="foo", meta="bar") {
  This content will be visible if the custom constraint "foo" allows it.
}{
  This content will be visible if the authorization fails.
}</pre>
          </p>

          <p><strong>Define a <code>DeadboltHandler</code> in the template.</strong>  This is possible, but I recommend against it as it can reduce code re-use.  See the next example for a better approach.
          <pre>@dynamic(name="foo", handler=new com.example.SomeSpecificDeadboltHandler()) {
  This content will be visible if the custom constraint "foo" allows it.
}</pre>
          </p>

          <p><strong>Pass a <code>DeadboltHandler</code> into the template.</strong>  This provides a more flexible approach to hard-coding the <code>DeadboltHandler</code> in the template.
          <pre>@(mySpecificDeadboltHandler: be.objectify.deadbolt.java.DeadboltHandler)

@dynamic(name="foo", handler=mySpecificDeadboltHandler) {
  This content will be visible if the custom constraint "foo" allows it.
}</pre>
          </p>
          <span next-section section="templatePattern" label="pattern"></span>
      </div>
      <div ng-if="section == 'templatePattern'">
        <h3>pattern</h3>
        <p>In progress</p>
      </div>
  </div>
</div>
</div>
